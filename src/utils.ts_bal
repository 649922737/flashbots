// src/utils.ts

import { FlashbotsBundleProvider, FlashbotsBundleRawTransaction, FlashbotsBundleTransaction, SimulationResponse, SimulationResponseSuccess } from "@flashbots/ethers-provider-bundle"; 
import { BigNumber, providers, utils, Wallet } from "ethers";

export const ETHER = BigNumber.from(10).pow(18);
export const GWEI = BigNumber.from(10).pow(9);

// 修复：添加 export 关键字
export function gasPriceToGwei(gasPrice: BigNumber): string {
  return utils.formatUnits(gasPrice, "gwei");
}

// 修复：添加 export 关键字
export async function checkSimulation(
  flashbotsProvider: FlashbotsBundleProvider,
  signedBundle: Array<string>,
  sponsorAddress: string,
  provider: providers.StaticJsonRpcProvider
): Promise<BigNumber> {
  console.log("[模拟器] 正在模拟交易捆绑包...");
  let simulation: SimulationResponse; 
  try {
    const latestBlockNumber = await provider.getBlockNumber();
    simulation = await flashbotsProvider.simulate(signedBundle, latestBlockNumber + 1);
  } catch (e: any) {
    console.error("[模拟器错误] 调用 Flashbots 模拟器失败:", e);
    if (e.code === 'SERVER_ERROR' && e.serverError && e.serverError.code === 'ETIMEDOUT') {
      console.warn("[模拟器警告] Flashbots 模拟器连接超时。请检查网络或代理。");
      throw new Error("Flashbots 模拟器连接超时。");
    }
    throw new Error(`Flashbots 模拟器调用失败: ${e.message || e.toString()}`);
  }

  if ('error' in simulation) {
    const errorResponse = simulation as { error: { code: number; message: string; } }; 
    
    if (errorResponse.error.message.includes("insufficient funds for gas * price + value")) {
      console.warn("[模拟器警告] Flashbots 模拟器报告余额不足。");
      console.warn(`[模拟器详情] 错误信息: ${errorResponse.error.message}`);
      
      const match = errorResponse.error.message.match(/have (\d+) want (\d+)/);
      if (match) {
        const simulatedHave = BigNumber.from(match[1]);
        const simulatedWant = BigNumber.from(match[2]);
        console.warn(`[模拟器详情] 模拟器认为赞助者有: ${utils.formatEther(simulatedHave)} ETH, 需要: ${utils.formatEther(simulatedWant)} ETH`);

        try {
          const actualSponsorBalance = await provider.getBalance(sponsorAddress);
          console.warn(`[诊断] 赞助者账户 (${sponsorAddress}) 的实际链上余额为: ${utils.formatEther(actualSponsorBalance)} ETH`);

          if (actualSponsorBalance.gte(simulatedWant)) {
            console.warn("[模拟器警告] 实际链上余额充足，Flashbots 模拟器可能存在缓存延迟。程序将尝试继续。");
            console.warn("[模拟器] 模拟结果中未直接返回 gasPrice，使用默认值 1 Gwei。");
            return BigNumber.from(utils.parseUnits("1", "gwei")); 
          }
        } catch (balanceError: any) {
          console.error(`[诊断] 无法获取赞助者账户实际余额进行对比：`, balanceError);
          throw new Error(`无法获取赞助者账户实际余额: ${balanceError.message || balanceError.toString()}`);
        }
      }
    }
    throw new Error(`Similuation failed, error code: ${errorResponse.error.code}, message: ${errorResponse.error.message}`);
  } else {
    const successSimulation = simulation as SimulationResponseSuccess;

    if (successSimulation.coinbaseDiff.eq(0)) {
      throw new Error("Does not pay coinbase");
    }

    const gasUsed = successSimulation.results.reduce(
      (acc: number, txSimulation: any) => acc + txSimulation.gasUsed,
      0
    );

    if (gasUsed === 0) {
        throw new Error("Simulated gasUsed is zero, cannot calculate gasPrice.");
    }

    const gasPrice = successSimulation.coinbaseDiff.div(BigNumber.from(gasUsed));
    console.log(`[模拟器] 模拟成功，计算出的 Gas Price: ${gasPriceToGwei(gasPrice)} Gwei`);
    return gasPrice;
  }
}

// 修复：添加 export 关键字
export async function printTransactions(
  bundleTransactions: Array<FlashbotsBundleTransaction | FlashbotsBundleRawTransaction>, 
  signedBundle: Array<string>
): Promise<void> {
  console.log("--------------------------------");
  console.log(
    (
      await Promise.all(
        bundleTransactions.map(
          async (bundleTx, index) => {
            const tx = 'signedTransaction' in bundleTx ? utils.parseTransaction(bundleTx.signedTransaction) : bundleTx.transaction
            const from = 'signer' in bundleTx ? await bundleTx.signer.getAddress() : tx.from

            return `TX #${index}: ${from} => ${tx.to} : ${tx.data}`
          })
      )
    ).join("\n")
  );

  console.log("--------------------------------");
  console.log(
    (
      await Promise.all(
        signedBundle.map(async (signedTx, index) => `TX #${index}: ${signedTx}`)
      )
    ).join("\n")
  );

  console.log("--------------------------------");
}

